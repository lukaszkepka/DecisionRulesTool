//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;

namespace DecisionRulesTool.Model.RuleTester
{
    using DecisionRulesTool.Model.Model;
    using System.Diagnostics;

    public class ConfusionMatrix
    {
        private int globalCount;
        private ICollection<RealDecisionRow> decisionClassRows;

        public string[] AvailableValues => decisionClassRows.Select(x => x.DecisionClass).ToArray();


        public ConfusionMatrix(Attribute decisionAttribute)
        {
            decisionClassRows = new List<RealDecisionRow>();
            string[] availableValues = ClassificationResult.GetDecisionClasses(decisionAttribute);

            for (int i = 0; i < availableValues.Count(); i++)
            {
                decisionClassRows.Add(new RealDecisionRow(availableValues, i));
            }
        }

        public void Initialize(int[,] values)
        {
            int j = 0;
            string[] availableValues = decisionClassRows.Select(x => x.DecisionClass).ToArray();

            foreach (var item in decisionClassRows)
            {
                for (int i = 0; i < availableValues.Length; i++)
                {
                    item.SetPredictionCount(availableValues[i], values[i, j]);
                }
                j++;
            }
        }

        public decimal Coverage
        {
            get
            {
                int noCoverageCount = 0;
                foreach (var realDecisionRow in decisionClassRows)
                {
                    noCoverageCount += realDecisionRow[ClassificationResult.NoCoverage];
                }
                return (decimal)(globalCount - noCoverageCount) / globalCount;
            }
        }

        public decimal Accuary
        {
            get
            {
                int u = 0;
                int truePositivesNegativesCount = 0;
                int i = 0;
                foreach (var realDecisionRow in decisionClassRows)
                {
                    u += realDecisionRow[ClassificationResult.NoCoverage];
                    truePositivesNegativesCount += realDecisionRow[i++];
                }


                int y = globalCount - u;

                return y == 0 ? 0 : (decimal)(truePositivesNegativesCount) / y;
            }
        }

        public int GetConfusionValue(string realClass, string predictedClass)
        {
            return decisionClassRows.FirstOrDefault(x => x.DecisionClass.Equals(realClass))[predictedClass];
        }

        public void IncrementPredictionCount(string realClass, string predictedClass)
        {
            globalCount++;
            decisionClassRows.FirstOrDefault(x => x.DecisionClass.Equals(realClass)).IncrementPredictionCount(predictedClass);
        }

        public class RealDecisionRow
        {
            private IDictionary<string, int> predictionHistogram;

            public string DecisionClass { get; }

            public RealDecisionRow(string[] decisionClasses, int classIndex)
            {
                DecisionClass = decisionClasses[classIndex];
                predictionHistogram = new Dictionary<string, int>();

                foreach (var decisionClass in decisionClasses)
                {
                    predictionHistogram.Add(decisionClass, 0);
                }
            }

            public int this[string decisionClass]
            {
                get
                {
                    return predictionHistogram[decisionClass];
                }
            }

            public int this[int decisionIndex]
            {
                get
                {
                    var key = predictionHistogram.Keys.ElementAt(decisionIndex);
                    return predictionHistogram[key];
                }
            }

            public int Count()
            {
                int count = 0;
                foreach (var key in predictionHistogram.Keys)
                {
                    count += predictionHistogram[key];
                }
                return count;
            }

            public void SetPredictionCount(string decisionClass, int value)
            {
                if (predictionHistogram.ContainsKey(decisionClass))
                {
                    predictionHistogram[decisionClass] = value;
                }
                else
                {
                    Debug.WriteLine($"Decision class : {decisionClass} is not valid for confusion matrix");
                }
            }

            public void IncrementPredictionCount(string decisionClass)
            {
                if (predictionHistogram.ContainsKey(decisionClass))
                {
                    predictionHistogram[decisionClass]++;
                }
                else
                {
                    Debug.WriteLine($"Decision class : {decisionClass} is not valid for confusion matrix");
                }
            }
        }
    }
}

